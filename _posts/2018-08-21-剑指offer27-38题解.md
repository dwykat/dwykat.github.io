---
layout: post
title: "剑指offer 第四章 题27-38题解 Python版"
description: "剑指offer27-38题解"
categories: [Code]
tags: [python, code, 剑指offer]
redirect_from:
  - /2018/08/21/
---
* Kramdown table of contents
{:toc .toc}
* * *
## 剑指offer 第四章题解
### 1. 举例让抽象问题具体化
> 如果没有思路，那就尝试手推几个例子吧。

* * *
#### 题30：包含min函数的栈
> 使用辅助栈，辅助栈与主栈同步增长，辅助栈中放入已压入元素的最小值；辅助栈与主栈同步弹出；

```python
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        self.stack = []
        self.stack_min = []
        self.min_value = None

    def push(self, node):
        if not self.stack:
            self.min_value = node
        else:
            self.min_value = min(self.min_value, node)
            
        self.stack.append(node)
        self.stack_min.append(self.min_value)

    def pop(self):
        self.stack_min.pop()
        return self.stack.pop()

    def top(self):
        return self.stack[-1]

    def min(self):
        return self.stack_min[-1]
```

* * *
#### 题31：栈的压入、弹出序列
**解法：** <br>
如果要判断一个序列是不是栈的弹出序列，那么把压入序列真正的压入一遍就知道了。此题分析如下：
1. 设立一个辅助栈和两个变量用作标志，一个指向弹出序列中的待弹出元素，一个指向压入序列中还未压入栈的元素，两个变量初始值都为0；
2. 如果待弹出元素和栈顶元素不相同，那么就去待压入元素中寻找和待弹出元素相等的值，将其压入栈；<br>
3. 如果待弹出元素和栈顶元素相同，那么弹出栈顶，待弹出元素往后继续，重复这个过程直到变成条件2，再重复条件2；
4. 在3中如果找不到相等元素，那么就说明弹出序列有问题。

```python
# -*- coding:utf-8 -*-
class Solution:
    def IsPopOrder(self, pushV, popV):
        if len(pushV) != len(popV):
            return False

        stack = []
        cur_push = 0
        cur_pop = 0
        while stack or cur_push < len(pushV):
            # cur_pop与栈顶相同，则弹出，cur_pop + 1
            if stack and stack[-1] == popV[cur_pop]:
                stack.pop()
                cur_pop += 1
            else:
                # cur_pop与栈顶不同，那么开始压栈，直到找到相等值
                while cur_push < len(pushV) and pushV[cur_push] != popV[cur_pop]:
                    stack.append(pushV[cur_push])
                    cur_push += 1
                if cur_push < len(pushV):
                    stack.append(pushV[cur_push])
                    cur_push += 1
                # 去除长度不等之外的唯一错误情况：找不到相等值压栈
                else:
                    return False

        return True
```

* * *
#### 题32：字符串的排列

**解法：** <br>
全排列问题，可以用递归做。递归做的越多越发现有时候递归不是很好写。暂定以后的递归套路为分析最后情况，制定basecase必须要给递归返回有利条件。

```python
# -*- coding:utf-8 -*-
class Solution:
    def Permutation(self, ss):
        if ss is None or len(ss) < 2:
            return ss
        ss = list(ss)
        res = set({})
        self.permut(ss, 0, res)

        return sorted(list(res))

    def permut(self, ss, begin, res):
        if begin == len(ss) - 1:
            res.add(''.join(ss))
            return

        cur = begin
        for cur in range(begin, len(ss)):
            self.swap(ss, begin, cur)    # 交换
            self.permut(ss, begin+1, res)
            self.swap(ss, begin, cur)    # 复位

    def swap(self, ss, i, j):
        ss[i], ss[j] = ss[j], ss[i]
```
