---
layout: post
title: "排序总结"
description: "排序总结"
categories: [Code]
tags: [python, code]
redirect_from:
  - /2018/08/19/
---
* Kramdown table of contents
{:toc .toc}

## 排序总结：
### 对数器：
> 对数器用来检测自定义排序算法是否正确。以下排序算法都经过10万个随机数组测试。

```python
import random


class Comparator():
    def compare(self, arr):
        return sorted(arr)

    def generate_arr(self, max_length, max_value):
        length = random.randint(0, max_length)
        arr = [random.randint(-max_value, max_value) for i in range(length)]

        return arr

    def confirm(self, arr1, arr2):
        return arr1 == arr2
```

### 1. 堆排序
> 堆是一个极其重要的数据结构，堆排序主要是利用了堆的思想,其时间复杂度为`O(N*logN)`,额外空间复杂度为`O(1)`。<br>
&emsp;&emsp;1.将数组调整成大根堆：<br>
&emsp;&emsp;&emsp;&emsp;在数组中，如果我们把index i位置的数字看作是根节点，那么它的左子节点在`index (2 * i) + 1`位置，右子节点在`index (2 * i) + 2`位置。反之index i位置的节点的父节点的位置在`(i - 1) // 2`位置。遍历数组添加元素，对每个新添加的元素执行`heap_insert`操作，从加入点开始上浮，直到上浮到合适位置；<br>
&emsp;&emsp;2.将大根堆顶与数组中最后一个元素交换，然后在不包括最后一个元素的数组区间执行`heapify`操作<br>
&emsp;&emsp;&emsp;&emsp;在堆顶与数组中最后一个元素交换后，我们需要重新调整堆，使得堆顶最大；<br>
&emsp;&emsp;3.重复2，直到可执行区间为1

#### 代码：
```python
class HeapSort():

    def heapsort(self, arr):
        if arr is None or len(arr) < 2:
            return arr

        length = len(arr)
        for i in range(length):
            self.heap_insert(arr, i)


        self.swap(arr, 0, length - 1)
        size = length - 2
        while size > 0:
            self.heapify(arr, 0, size)
            self.swap(arr, 0, size)
            size -= 1

    def heap_insert(self, arr, i):

        while i > 0:
            parent = (i - 1) // 2
            if arr[parent] > arr[i]:
                break
            else:
                self.swap(arr, parent, i)
                i = parent

    def heapify(self, arr, i, size):
        left = 2 * i + 1
        while left <= size:
            right = 2 * i + 2
            largest = right if right <= size and arr[right] >= arr[left] else left
            largest = largest if arr[largest] >= arr[i] else i
            if largest == i:
                break
            self.swap(arr, largest, i)
            i = largest
            left = 2 * i + 1

    def swap(self, arr, i, j):
        arr[i], arr[j] = arr[j], arr[i]
```

### 快排
> 随机快排就是随机+partition的过程。partition过程其实就是荷兰国旗问题。

#### 代码：
```python
import random


class QuickSort():
    def quick_min(self, arr):
        if arr is None or len(arr) < 2:
            return arr

        self.quick_sort(arr, 0, len(arr) - 1)

    def quick_sort(self, arr, l, r):
        if l < r:
            self.swap(arr, random.randint(l, r), r)
            left, right = self.partation(arr, l, r)
            self.quick_sort(arr, l, left)
            self.quick_sort(arr, right, r)

    def partation(self, arr, l, r):
        left = l - 1
        right = r
        while l < right:
            if arr[l] < arr[r]:
                left += 1
                self.swap(arr, l, left)
                l += 1
            elif arr[l] == arr[r]:
                l += 1
            else:
                right -= 1
                self.swap(arr, l, right)

        self.swap(arr, right, r)
        return left, right + 1

    def swap(self, arr, i, j):
        arr[i], arr[j] = arr[j], arr[i]
```



